
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title><%= htmlWebpackPlugin.options.title %></title>
    <style>
      body {
        margin: 0 auto;
        width: 1000px;
      }
      .row {
        display: flex;
        justify-content: space-between;
      }
      .row--code {
        display: flex;
        justify-content: flex-start;
      }
      .border-sides {
        padding-left: 20px;
        border-left: 1px solid #aaa;
        border-right: 1px solid #aaa;
      }
      .border-right {
        margin-right: 20px;
        padding-right: 20px;
        border-right: 1px solid #aaa;
      }
    </style>
  </head>
  <body>
    <h2>Explaining monads via a series of tubes</h2>
    <p>
      Let's provide some motivation for working with monads, i.e. flatMappable structures. We will explore different ways to add logging to a function in JavaScript
      (augmented with Flow type annotations), ultimately arriving at a flatMap approach. We will first visualize our functions as a pipe that takes in an input and
      returns an output. We will then manually add our extra behavior using <em>console.log</em>. We will then use a decorator function to perform the same modification
      automatically. We will then explore further implementations without using <em>console.log</em>. We will first use <em>map</em> and define a functor. We will
      then use <em>flatMap</em> and define a monad. Finally we will refactor our <em>flatMap</em> implementation into idiomatic JavaScript.

    <h3>Initial functions</h3>
    <p>
      Let's examine a few initial functions: <em>double</em>, <em>addOne</em>, and <em>ceiling</em>. We will be exploring ways of modifying these
      functions while keeping their essence intact. For simplicity, all our functions take in a number as input and return a number as output. This allows us
      to combine our functions together in any order we want.
    </p>
    <div class="row">
      <div>
        <div id="double">
            double
      5 -> ======== -> 10
        </div>
        <pre>
function double(x: number): number {
  return x * 2;
}
        </pre>
        <p><em>double</em> doubles its input.</p>
      </div>
      <div class="border-sides">
        <div id="add-one">
        addOne
    6 -> ======== -> 7
        </div>
        <pre>
function addOne(x: number): number {
  return x + 1;
}
        </pre>
        <p><em>addOne</em> adds one to its input.</p>
      </div>
      <div>
        <div id="ceiling">
            ceiling
    10.5 -> ========= -> 11
        </div>
        <pre>
function ceiling(x: number): number {
  return Math.ceil(x);
}
        </pre>
        <p><em>ceiling</em> rounds its input to the next highest integer.</p>
      </div>
    </div>
    <h3>Using our functions</h3>
    <p>Here are a few ways we can compose the functions <em>double</em>, <em>addOne</em>, and <em>ceiling</em>.

    <div id="compose-normal-1">
        double              ceiling            addOne
5.2 -> ======== -> 10.4 -> ========= -> 11 -> ======== -> 12
    </div>
    <pre>
addOne(ceiling(double(5.2))) // => 12
    </pre>

    <div id="compose-normal-2">
        addOne             double              ceiling
5.2 -> ======== -> 6.2 -> ======== -> 12.4 -> ========= -> 13
    </div>
    <pre>
ceiling(double(addOne(5.2))) // => 13
    </pre>

    <div id="compose-normal-3">
        double              addOne              double               ceiling
5.2 -> ======== -> 10.4 -> ======== -> 11.4 -> ========= -> 22.8 -> ========= -> 23
    </div>
    <pre>
ceiling(double(addOne(double(5.2)))) // => 23
    </pre>
    <p>Because all inputs and outputs are compatible with each other, we can combine our functions in any order.</p>

    <h3>How can we trace function calls?</h3>
    <p>
      What if we want to know when these functions are called? For example, what if we're exploring a code base, and are
      trying to determine the order in which functions are being executed? We could figure this out by reading through source code, but it's
      very easy to get lost as we come across conditionals and jump through multiple files. Another approach is to modify our functions to
      log their name before returning their value. Then we can scan through our logs to see the order in which our functions are being called.
    </p>

    <h3>A manual approach</h3>
    <p>
      One way we can add function call tracing is to manually modify our functions.
    </p>

    <div class="row">
    <div>
      <div id="double-altered">
          double
  5.2 -> ===-==== 10.4
            |
            V
        double was called
      </div>
      <pre>
function double(x: number): number {
  console.log("double was called")
  return x * 2;
}
      </pre>
    </div>

    <div class="border-sides">
      <div id="add-one-altered">
          addOne
  5.2 -> ===-==== 6.2
            |
            V
        addOne was called
      </div>
      <pre>
function addOne(x: number): number {
  console.log("addOne was called")
  return x + 1;
}
      </pre>
    </div>

    <div>
      <div id="ceiling-incorrectly-altered">
          ceiling
  5.2 -> ===-===== 6
            |
            V
        addOne was called
      </div>
      <pre>
function ceiling(x: number): number {
  console.log("addOne was called")
  return Math.ceil(x);
}
      </pre>
    </div>
    </div>
    <p>
      Here we've manually added a <em>console.log</em> statement to each one of our original functions. Simply adding <em>console.log</em> does not
      affect the return value of our functions. Because inputs and outputs are not affected, we can compose our new functions as we did our
      old ones.
    </p>
    <div id="compose-altered"></div>
    <pre>
addOne(ceiling(double(5.2))) // => 12
    </pre>
    <p>
      However, manually modifying each function is quite tedious and error prone. In fact, our new <em>ceiling</em> has a bug.
      Rather than logging "ceiling called", it logs "addOne called." This type of copy paste bug can be quite easy to miss. Can we devise a less
      labor intensive, less error prone approach?
    </p>
    <h3>Using a decorator</h3>
    <p>
      Let's build some infrastructure that will allow us to automatically modify our functions. We will create a decorator function to do the work for us.
      As a quick refresher, a decorator function (commonly seen when doing Aspect Oriented Programming) takes a function as input and returns a new function as output. When this new function is called, it will
      execute some predefined behavior (in our case it will log out the original function's name) and then return the result of calling the original function.
    </p>
    <p>
      Let's define a decorator called <em>logName</em>. Our <em>logName</em> decorator will take a function in the shape of <em>double</em>, <em>addOne</em>,
      or <em>ceiling</em> as input. It will return a new function i.e. <em>double'</em>, <em>addOne'</em>, or <em>ceiling'</em>. This returned function will
      log the original function's name before returning the newly computed value. In order to retrieve the original function's name, we will be using the
      function's <em>name</em> property to dynamically determine the correct name to log out.
    </p>
    <p>
      As an aside, <em>double'</em>, <em>addOne'</em>, and <em>ceiling'</em> are not valid JavaScript names. Single quotes are not allowed within function names.
      Let's ignore this -- we use the single quote to denote that our original function has been altered.
    </p>
    <div id="double-decorated"></div>
    <pre>
function logName(fn: (number) => number) {
  return function(x: number) {
    <%= "console.log(`${f.name} was called`);" %>
    return f(x);
  }
}

const double' = logName(double);
double'(3) // => 6

// or equivalently

logName(double)(3) // => 6
    </pre>
    <p>
      Here we see that we've generated a new function <em>double'</em> based on our existing <em>double</em>. A <em>double</em> function goes
      in to the decorator, and a new function <em>double'</em> comes out of the decorator. Both functions double their input, but the new <em>double'</em>
      differs from the original <em>double</em> because it logs out "double called" prior to returning its result. The original <em>double</em> does not.
      Because both functions take in numbers as input, and return the doubled number as output, we can use the new <em>double'</em> exactly
      as we use the original <em>double</em>.
    </p>
    <p>Let's generate modified functions for <em>addOne</em>, and <em>ceiling</em> as well.

    <div class="row--code">
      <div class="border-right">
        <div id="add-one-decorated"></div>
        <pre>
const addOne' = logName(addOne)
addOne'(11) // => 12
        </pre>
      </div>
      <div>
      <div id="ceiling-decorated"></div>
        <pre>
const ceiling' = logName(ceiling)
ceiling'(11.1) // => 12
        </pre>
      </div>
    </div>
    <p>We can compose our new functions as we did our old functions.</p>

    <pre>
ceiling'(double'(addOne'(5.2))) // => 13
    </pre>
    <div id="compose-decorated"></div>
    <p>
      Moreover, because this modification process was automatic, we've fixed the original copy paste bug. Our modified <em>ceiling'</em> function correctly
      logs the original <em>ceiling</em>'s name instead of logging out <em>addOne</em>'s name.
    </p>
    <h3>Without side effects</h3>
    <p>
      Introducing a side effect, i.e. interacting with the outside world, is a quick and easy way to tack additional behavior on to a function. Our previous implementations
      use <em>console.log</em>, a side effect, to tell the world that a function was called. One limitation of this approach is that once we log our function call
      we can no longer directly interact with that data. For example, how can we find the most commonly used function? We would have to dig into our logs
      to tally up total counts.
    </p>
    <p>
      Instead of using a side effect, we can incorporate relevant information directly into the return value. For example, we can represent our function call history as a
      list of strings. Then instead of returning a number directly, our functions can instead return that number and the history of function calls side by side. This
      approach has the benefit of making our function call history immediately consumable. For example, finding the most commonly used function is as simple as
      finding the most frequently appearing string in a list of strings.
    </p>
    <p>
      However, modifying a function's return type is a very heavy handed approach. Our existing functions only know how to consume numbers. They do not know how to
      handle any extra information. If we want our functions to remain compatible with each other, we will need to modify all of them to handle this extra data.
    </p>
    <p>For example, here we modify <em>double</em> to return extra information, but do not modify <em>addOne</em> to accept extra information:</p>
    <pre>
5 -> =double===== -> { value: 5, history: ["double called"] } -!-> ===== addOne ====
    </pre>
    <p>
      As we can see, <em>addOne</em> does not know what to do with <em>double</em>'s output, and so the program crashes. This shows us that modifying return values
      have a much higher initial cost than simply using <em>console.log</em>. Where before we were free to mix and match logged and unlogged functions,
      we now can only use one or the other. Nevertheless, let's continue down this path.
    </p>
    <p>
      Let's start by defining our enhanced return value. Let's call it <em>Log</em>. <em>Log</em> will have two properties -- <em>value</em>, a number, and
      <em>history</em>, a list of strings. These strings will represent all function names that have been called up to the current point.
    </p>
    <div class="row--code">
      <div class="border-right">
        <p>
          Here is the definition of our <em>Log</em> type:
        </p>
        <pre>
type Log = {
  value: number,
  history: string[],
};
        </pre>
      </div>
      <div>
        <p>Here is an instance of a <em>Log</em> object:</p>
        <pre>
{
  value: 30,
  history: [
    "double called",
    "ceiling called",
    "addOne called",
  ],
}
        </pre>
      </div>
    </div>
    <p>
      The above sample <em>Log</em> object has a current value of 30. Moreover our log tells us that it first passed through our <em>double</em> function. Afterwards,
      it passed through <em>ceiling</em>, and finally <em>addOne</em>. Based on that, here is one possible way to generate this log:
    </p>
    <pre>
14.1 -> double -> 28.2 -> ceiling -> 29 -> addOne -> 30
    </pre>
    <p>
      The above diagram only shows how our number passes through our pipeline of functions. Let's now show how the log itself develops.
    </p>
    <pre>
          {                     {                                  {
14.1 -> value: 14.1, -> double ->   value: 28.2,       -> ceiling ->   value: 29,          -> addOne -> { value: 30,
      history: []                  history: [                          history: [                          history: ["double called', "ceiling called", "addOne called"] }
    }                               "double called",                   "double called",
                                  ]                                    "ceiling called",
                                }                                    ]
                                                                    }
    </pre>
    <p>
      From the above diagram, we see that we've modified our functions to accept <em>Log</em> objects as inputs and return
      <em>Log</em> objects as outputs. Moreover, we kick things off by wrapping our original number in an initial <em>Log</em> object.
      This inaugural wrapping allows us to start using our <em>Log</em> enhanced functions.
    </p>
    <p>
      Here is a utility function that generates our initial <em>Log</em> object:
    </p>
    <pre>
function buildLog(value: number): Log {
  return {
    value: value,
    history: [],
  };
}
    </pre>
    <p>
      We insert our given number into the <em>Log</em> object we generate. Because no relevant functions have been called yet, we initialize
      <em>history</em> to an empty array. This fresh <em>Log</em> object will be the starting point to interact with our other functions.
    </p>
    <p>Now we must figure out how to modify our functions to accept and return logs.</p>
    <h3>A manual approach</h3>
    <p>Let's start with the manual approach.</p>

    <pre>
function double(log: Log): Log {
  const { value, history } = log;
  const doubled = value * 2;
  const newHistory = history.concat(["double called"]);
  return {
    value: doubled,
    history: newHistory,
  };
}

double({ value: 3, history: ["cheese"] }) // => { value: 6, history: ["cheese", "double called"] }
    </pre>
    <p>
      Here we see our enhanced <em>double</em> function. Rather than dealing with <em>number</em> inputs and outputs, it deals with <em>Log</em> inputs
      and outputs. As a result, it can no longer interact with <em>addOne</em> and <em>ceiling</em>.
    </p>
    <pre>
{ ... } -> double -> { ... } -!-> addOne
    </pre>
    <p>
      Let's modify <em>addOne</em>, and
      <em>ceiling</em> to handle <em>Log</em>s as well.
    </p>
    <div class="row--code">
      <div class="border-right">
        <pre>
function addOne(log: Log): Log {
  const { value, history } = log;
  const plusOne = value + 1;
  const newHistory = history.concat(["addOne called"]);
  return {
    value: plusOne,
    history: newHistory,
  };
}

addOne({ value: 4, history: [] })
  // => { value: 5, history: ["addOne called"] }
        </pre>
      </div>
      <div>
        <pre>
function ceiling(log: Log): Log {
  const { value, history } = log;
  const ceiling = Math.ceil(value);
  const newHistory = history.concat(["ceiling called"]);
  return {
    value: ceiling,
    history: newHistory,
  };
}

ceiling({ value: 3.5, history: ["fondue"] })
  // => { value: 4, history: ["fondue", "ceiling called"] }
        </pre>
      </div>
    </div>
    <p>
      Because all our functions now expect <em>Log</em> objects as inputs and return <em>Log</em> objects as outputs, we can
      compose them however we'd like. This is similar to our original functions that took numbers as inputs and returned numbers as
      outputs. However, rather then tracking function calls via <em>console.log</em>, we now track function calls via <em>Log</em>
      return values.
    </p>
    <pre>
                        double              ceiling            addOne            double
5.2 -> { 5.2, [] } -> ======== -> 10.4 -> ========= -> 11 -> ======== -> 12 -> ======== 24
    </pre>
    <pre>
double(addOne(ceiling(double(5.2)))) // => 24, ["double", "ceiling", "addOne", "double"]
    </pre>
    <p>
      There are a few drawbacks with our manual implementation. Much like when we manually added <em>console.log</em>s our original functions,
      this process is very repetitive. Moreover, there is a lot more code than simply logging a string to the console. Handling <em>Log</em>
      objects involved the following five steps:
    </p>
    <ol>
      <li>extract the existing value and history from our <em>Log</em> object</li>
      <li>perform the actual computation</li>
      <li>generate some new history</li>
      <li>combine the new history with the old history</li>
      <li>return the new <em>Log</em> object</li>
    </ol>
    <p>
      The only unique feature across <em>double</em>, <em>addOne</em>, and <em>ceiling</em> is the second step of performing
      the actual computation. All other steps are more or less the same. This suggests that we can create a decorator function
      to abstract away much of the repetition.
    </p>
    <h3>Using the map decorator</h3>
    <p>
      Much like our <em>traceCall</em> decorator added appropriate <em>console.log</em> statements to an initial function, our new
      <em>map</em> decorator will enhance an initial function to accept and return <em>Log</em> objects. It will achieve this by
      abstracting out the following steps as seen in the manual modification process:
    </p>
    <ol>
      <li>extract the existing value and history from an inputted <em>Log</em> object</li>
      <li>use the given function to perform some computation</li>
      <li>generate some new history</li>
      <li>combine the new history with the old history</li>
      <li>return the new <em>Log</em> object</li>
    </ol>
    <p>
      Here are the above steps translated into code form.
    </p>
    <pre>
function map(fn: (x: number) => number) {
  return function(log: Log): Log {
    const { value, history } = log;
    const newValue = fn(value);
    <%= "const newHistory = history.concat([`${fn.name} called`]);" %>
    return {
      value: newValue,
      history: newHistory,
    };
  }
}
    </pre>
    <p>
      Notice how similar this <em>map</em> implementation is to our manually modified functions. Here is how we can use it to generate
      <em>double'</em>, <em>addOne'</em>, and <em>ceiling'</em> dopplegangers based on our original <em>double</em>, <em>addOne</em>, and
      <em>ceiling</em> functions.
    </p>
    <pre>
    = double = -> === map === -> = double' =
    = addOne = -> === map === -> = addOne' =
    = ceiling = -> === ceiling === -> = ceiling' =
    </pre>
    <pre>
const double' = map(double);
const addOne' = map(addOne);
const ceiling' = map(ceiling);
    </pre>
    <p>
      Usage of our newly generated functions is exactly the same as when we manually made them.
    </p>
    <pre>
                        double              ceiling            addOne            double
5.2 -> { 5.2, [] } -> ======== -> 10.4 -> ========= -> 11 -> ======== -> 12 -> ======== 24
    </pre>
    <pre>
double'(addOne'(ceiling'(double'(buildTrace(5.2))))) // => 24, ["double", "ceiling", "addOne", "double"]
map(double)(
  map(addOne)(
    map(ceiling)(
      map(double)(
        buildTrace(5.2)
      )
    )
  )
) // => 24, ["double", "ceiling", "addOne", "double"]
    </pre>
    <p>
      What have we accomplished by defining <em>map</em>? We have created a mechanism where given a function that takes numbers to numbers,
      we can now generate a very similar function that takes <em>Trace</em>s to <em>Trace</em>s.
    </p>
    <p>
      At this point one might wonder why we've named our decorator <em>map</em>. We'll soon see that our <em>map</em> decorator
      very similar to lodash's <em>map</em> function. Let's take a look at lodash's <em>map</em>'s type signature:
    </p>
    <pre>
function lodashMap&lt;U, V&gt;(collection: Array&lt;U&gt;, fn: (u: U) => V): Array&lt;V&gt;
    </pre>
    <p>
      In comparison, here are more generic versions of our <em>map</em> and <em>Log</em>:
    </p>
    <div class="row--code">
    <pre class="border-right">
function map&lt;U, V&gt;(fn: (u: U) => V): (Log&lt;U&gt;) => Log&lt;V&gt;
    </pre>
    <pre>
type Log&lt;T&gt; = {
  value: T,
  history: string[],
};
    </pre>
    </div>
    <p>
      Our <em>map</em>'s type signature is the curried form of the following signature for <em>map</em> -- we can easily
      rewrite <em>map</em> to take on the following uncurried form:
    </p>
    <pre>
function map&lt;U, V&gt;(fn: (u: U) => V, log: Log&lt;U&gt;): Log&lt;V&gt;
    </pre>
    <p>
      On the left is our curried <em>map</em> as originally defined, and on the right is our new, equivalent, uncurried map:
    </p>
    <div class="row--code">
      <div class="border-right">
        <pre>
function map(fn: (x: number) => number) {
  return function(log: Log): Log {
    const { value, history } = log;
    const newValue = fn(value);
    <%= "const newHistory = history.concat([`${fn.name} called`]);" %>
    return {
      value: newValue,
      history: newHistory,
    };
  }
}
        </pre>
      </div>
      <div>
        <pre>
function map(fn: (x: number) => number, log: Log) {
  const { value, history } = log;
  const newValue = fn(value);
  <%= "const newHistory = history.concat([`${fn.name} called`]);" %>
  return {
    value: newValue,
    history: newHistory,
  };
}
        </pre>
      </div>
    </div>
      Now let's compare our uncurried <em>map</em> with <em>lodash</em>'s <em>map</em>.
    </p>
    <pre>
function lodashMap&lt;U, V&gt;(collection: Array&lt;U&gt;, fn: (u: U) => V): Array&lt;V&gt;
function       map&lt;U, V&gt;(fn: (u: U) => V,          log: Log&lt;U&gt;): Log&lt;V&gt;
    </pre>
    <p>
      Here we see two differences in function shapes. A minor difference is that the order of arguments are reversed -- lodash expects the array
      to be passed in first, whereas we expect the function to be passed in first. The second, more interesting difference is that while our <em>map</em>
      operates on <em>Log</em> objects, <em>lodash</em>'s <em>map</em> operates on <em>Array</em>s. These are
      very different data structures, but their respective <em>map</em>s conceptually do very similar things.
    </p>
    <h3>A functor is a mappable structure</h3>
    <p>
      The similarity between our <em>Log</em>'s <em>map</em> and an array's <em>map</em> is not an isolated occurrence. There are many more
      structures such as <em>Promise</em> and <em>Maybe</em> that can have very similar <em>map</em> functions defined for them. Collectively,
      if these mappable structures obey certain other laws, they are known as functors. Here is a definition of a functor:
    </p>
    <p>
      A functor contains two components:
      <ul>
        <li>
          A structure that wraps a value or value
          <pre>
type Functor&lt;T&gt;;
          </pre>
        </li>
        <li>
          A <em>map</em> function in the shape of:
          <pre>
function map&lt;U, V&gt;(fn: (u: U) => V, f: Functor&lt;U&gt;): Functor&lt;V&gt;;
          </pre>
        </li>
      </ul>
    </p>
    <p>Moreover, a functor should obey the following laws:</p>
      <ul>
        <li>
          <div class="row--code">
            <div class="border-right">
              Identity law
              <pre>
    map(identity, functor) &#65309; identity(functor)
              </pre>
            </div>
            <div>
              where <em>identity</em> is a function that directly returns its argument:
              <pre>
function identity&lt;T&gt;(x: T): T {
  return x;
}
              </pre>
            </div>
          </div>
        </li>
        <li>
          Composition law
          <pre>
map((x) => f(g(x)), functor) &#65309; map(f, map(g, functor))
          </pre>
        </li>
      </ul>
      <p>
        Here we hit a minor roadblock. Our our <em>Log</em> functor is not actually a functor! Namely, our log's
        <em>history</em> property obeys neither the identity law nor the composition law.
      </p>
    </p>
    <h3>Decomposing map into two stages</h3>
    <p>
      Upon closer examination, our original curried <em>map</em> function does two conceptually different things. We can divide it into two stages:
    </p>
    <ol>
      <li>
        <p>
          A decorator that converts a function in the shape of
          <pre>
(number) => number
          </pre>
          into a function in the shape of
          <pre>
(number) => Log
          </pre>
          It is responsible for building an initial <em>Log</em> object.
        </p>
      </li>
      <li>
        <p>
          A decorator that converts a function in the shape of
          <pre>
(number) => Log
          </pre>
          into a function in the shape of
          <pre>
(Trace) => Log
          </pre>
          It is responsible for gluing two <em>Log</em> objects together.
        </p>
      </li>
    </ol>
    </div>
    <p>
      We will soon see that our second decorator is called <em>flatMap</em>, and that we can call flatMappable structures monads. But first let's
      provide some motivation as to why we'd want to decompose one decorator into two decorators in the first place.
    </p>
  </body>
</html>
